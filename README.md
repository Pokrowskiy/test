Получилось, что получилось, очень много спагетти-кодинга, но я старался как мог.

Там походу тесты не проходят на ChaosMonkey из-за приколов каких-то. Поэтому сразу сообщу, что я реализовывал базовый функционал и отказы процессов. На остальное не хватило душевных сил.

Каждый участник группы хранит у себя список других участников группы, список участников, от которых он ожидает ответ на таймаут и список участников, которые были в сети, но вышли.

Обработка JOIN: 
1) Запускается таймер для синхронизации информации о группе
2) Проверяется, команда создаёт группу, или присоединяет процесс к уже существующей
3) Если присоединяет - запрашивает информацию о составе группы у того процесса, который используется как seed.

Обработка GET_MEMBERS:
1) Проверяет sender на то, состоял ли он в members. Если его там нет - добавляет как нового участника.
2) Проверяет sender по списку тех, кто состоял, но вышел. Если он выходил - то включает флаг 'rejoin' и удаляет его из своего списка вышедших
3) Передаёт фраг rejoin и свои списки участников и вышедших ВСЕМ известным участникам группы. (Я знаю, что это возможно не оптимальное решение, но иначе у меня не проходили тесты)

Обработка MEMBERS:
1) Проверяет флаг rejoin. Если флаг активен - заменяет свой список вышедших на полученный(в котором отсутствует переподключившийся участник), в противном случае - дополняет свой список полученным.
2) Дополняет сврй список участников полученным и удаляет из него всех вышедших.
3) Удаляет таймер таймаута.

Обработка LEAVE:
1) Удаляет себя из группы и рассылает всем участникам сообщение LEFT о своём выходе.

Обработка LEFT :
1) Удаляют вышедшего участника из списка активных участников и добавляют его в список вышедших участников.


Таймеры :

Для работы нужны несколько таймеров, один для запуска синхронизации и проверок работоспособности, и несколько таймеров для ожидания ответа каждого участника.
По таймеру для синхронизации(запускаемому в JOIN) участник запрашивает список участников у других и запускает таймер таймаута для запрошенного учатника. Таймер отключается, если от этого участника получен ответ, иначе он считается упавшим и тогда от его лица рассылается LEFT всем остальным участникам.
Я решил не делать отдельный hertbeat для определения того, насколько "Жовой" участник, раз уж мы всё равно ему посылаем запрос-ответ при синхронизации.

Тут конечно жесть получается ибо много участников, и все друг другу кидают пинги и синхронизации. Из-за этого тест на масштабируемость не проходит. Скорее всего, околооптимальным решением было бы иметь одного организатора, который бы всем заведовал и приделать логику выбора нового, если старый умер, но мне не хватило на это душевных сил.
